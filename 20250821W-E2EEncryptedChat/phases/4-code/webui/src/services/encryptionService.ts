// Encryption Service using WebCrypto API
// Generated by ae-framework Code Generation Agent

import { EncryptionKeys } from '@/types';

class EncryptionService {
  private keyPair: CryptoKeyPair | null = null;
  private sharedKeys: Map<string, CryptoKey> = new Map();

  async generateKeyPair(): Promise<CryptoKeyPair> {
    try {
      const keyPair = await window.crypto.subtle.generateKey(
        {
          name: 'RSA-OAEP',
          modulusLength: 2048,
          publicExponent: new Uint8Array([1, 0, 1]),
          hash: 'SHA-256',
        },
        true,
        ['encrypt', 'decrypt']
      );

      this.keyPair = keyPair;
      await this.storePrivateKey(keyPair.privateKey);
      return keyPair;
    } catch (error) {
      console.error('Error generating key pair:', error);
      throw error;
    }
  }

  async encryptMessage(message: string, recipientPublicKey: CryptoKey): Promise<ArrayBuffer> {
    try {
      // Generate AES key for message encryption
      const aesKey = await window.crypto.subtle.generateKey(
        {
          name: 'AES-GCM',
          length: 256,
        },
        true,
        ['encrypt', 'decrypt']
      );

      // Encrypt message with AES
      const iv = window.crypto.getRandomValues(new Uint8Array(12));
      const encodedMessage = new TextEncoder().encode(message);
      const encryptedMessage = await window.crypto.subtle.encrypt(
        {
          name: 'AES-GCM',
          iv: iv,
        },
        aesKey,
        encodedMessage
      );

      // Encrypt AES key with recipient's RSA public key
      const exportedAESKey = await window.crypto.subtle.exportKey('raw', aesKey);
      const encryptedAESKey = await window.crypto.subtle.encrypt(
        {
          name: 'RSA-OAEP',
        },
        recipientPublicKey,
        exportedAESKey
      );

      // Combine encrypted AES key, IV, and encrypted message
      const result = new ArrayBuffer(encryptedAESKey.byteLength + iv.byteLength + encryptedMessage.byteLength);
      const resultView = new Uint8Array(result);
      
      resultView.set(new Uint8Array(encryptedAESKey), 0);
      resultView.set(iv, encryptedAESKey.byteLength);
      resultView.set(new Uint8Array(encryptedMessage), encryptedAESKey.byteLength + iv.byteLength);

      return result;
    } catch (error) {
      console.error('Error encrypting message:', error);
      throw error;
    }
  }

  async decryptMessage(encryptedData: ArrayBuffer): Promise<string> {
    try {
      if (!this.keyPair?.privateKey) {
        throw new Error('Private key not available for decryption');
      }

      const dataView = new Uint8Array(encryptedData);
      
      // Extract encrypted AES key (first 256 bytes for RSA-2048)
      const encryptedAESKey = dataView.slice(0, 256);
      
      // Extract IV (next 12 bytes)
      const iv = dataView.slice(256, 268);
      
      // Extract encrypted message (remaining bytes)
      const encryptedMessage = dataView.slice(268);

      // Decrypt AES key with private RSA key
      const decryptedAESKeyBuffer = await window.crypto.subtle.decrypt(
        {
          name: 'RSA-OAEP',
        },
        this.keyPair.privateKey,
        encryptedAESKey
      );

      // Import AES key
      const aesKey = await window.crypto.subtle.importKey(
        'raw',
        decryptedAESKeyBuffer,
        {
          name: 'AES-GCM',
        },
        false,
        ['decrypt']
      );

      // Decrypt message with AES key
      const decryptedMessage = await window.crypto.subtle.decrypt(
        {
          name: 'AES-GCM',
          iv: iv,
        },
        aesKey,
        encryptedMessage
      );

      return new TextDecoder().decode(decryptedMessage);
    } catch (error) {
      console.error('Error decrypting message:', error);
      throw error;
    }
  }

  async exportPublicKey(): Promise<ArrayBuffer> {
    if (!this.keyPair?.publicKey) {
      throw new Error('No public key available');
    }

    return await window.crypto.subtle.exportKey('spki', this.keyPair.publicKey);
  }

  async importPublicKey(keyData: ArrayBuffer): Promise<CryptoKey> {
    return await window.crypto.subtle.importKey(
      'spki',
      keyData,
      {
        name: 'RSA-OAEP',
        hash: 'SHA-256',
      },
      false,
      ['encrypt']
    );
  }

  private async storePrivateKey(privateKey: CryptoKey): Promise<void> {
    try {
      const exportedKey = await window.crypto.subtle.exportKey('pkcs8', privateKey);
      
      // Store in IndexedDB
      const request = indexedDB.open('E2EChatKeys', 1);
      
      request.onupgradeneeded = (event) => {
        const db = (event.target as IDBOpenDBRequest).result;
        if (!db.objectStoreNames.contains('keys')) {
          db.createObjectStore('keys');
        }
      };

      request.onsuccess = (event) => {
        const db = (event.target as IDBOpenDBRequest).result;
        const transaction = db.transaction(['keys'], 'readwrite');
        const store = transaction.objectStore('keys');
        store.put(exportedKey, 'privateKey');
      };
    } catch (error) {
      console.error('Error storing private key:', error);
    }
  }

  async loadPrivateKey(): Promise<CryptoKey | null> {
    try {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open('E2EChatKeys', 1);
        
        request.onsuccess = (event) => {
          const db = (event.target as IDBOpenDBRequest).result;
          const transaction = db.transaction(['keys'], 'readonly');
          const store = transaction.objectStore('keys');
          const getRequest = store.get('privateKey');
          
          getRequest.onsuccess = async () => {
            if (getRequest.result) {
              try {
                const privateKey = await window.crypto.subtle.importKey(
                  'pkcs8',
                  getRequest.result,
                  {
                    name: 'RSA-OAEP',
                    hash: 'SHA-256',
                  },
                  false,
                  ['decrypt']
                );
                resolve(privateKey);
              } catch (error) {
                reject(error);
              }
            } else {
              resolve(null);
            }
          };
          
          getRequest.onerror = () => {
            reject(getRequest.error);
          };
        };
        
        request.onerror = () => {
          reject(request.error);
        };
      });
    } catch (error) {
      console.error('Error loading private key:', error);
      return null;
    }
  }

  async clearKeys(): Promise<void> {
    this.keyPair = null;
    this.sharedKeys.clear();
    
    // Clear from IndexedDB
    const request = indexedDB.open('E2EChatKeys', 1);
    request.onsuccess = (event) => {
      const db = (event.target as IDBOpenDBRequest).result;
      const transaction = db.transaction(['keys'], 'readwrite');
      const store = transaction.objectStore('keys');
      store.clear();
    };
  }
}

export const encryptionService = new EncryptionService();