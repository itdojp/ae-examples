// Custom React Hooks
// Generated by ae-framework Code Generation Agent

import { useState, useEffect, useCallback } from 'react';
import { useDispatch, useSelector } from 'react-redux';
import { RootState } from '@/store';
import { websocketService } from '@/services/websocketService';
import { apiService } from '@/services/apiService';
import { encryptionService } from '@/services/encryptionService';
import { loginSuccess, addMessage, updateReadStatus } from '@/store';

// WebSocket Hook
export const useWebSocket = (url?: string) => {
  const [connected, setConnected] = useState(false);
  const [connecting, setConnecting] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const connect = useCallback(async () => {
    try {
      setConnecting(true);
      setError(null);
      await websocketService.connect(url);
      setConnected(true);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Connection failed');
      setConnected(false);
    } finally {
      setConnecting(false);
    }
  }, [url]);

  const disconnect = useCallback(() => {
    websocketService.disconnect();
    setConnected(false);
  }, []);

  useEffect(() => {
    return () => {
      disconnect();
    };
  }, [disconnect]);

  return {
    connected,
    connecting,
    error,
    connect,
    disconnect,
    markAsRead: websocketService.markAsRead.bind(websocketService),
    getReadStatus: websocketService.getReadStatus.bind(websocketService),
  };
};

// Authentication Hook
export const useAuth = () => {
  const dispatch = useDispatch();
  const auth = useSelector((state: RootState) => state.auth);
  const [loading, setLoading] = useState(false);

  // Check for existing auth token on initialization
  useEffect(() => {
    const token = localStorage.getItem('authToken');
    if (token && !auth.isAuthenticated) {
      // Verify token with backend and restore auth state
      // For now, we'll assume the token is valid if it exists
      // In production, you should validate with the backend
      try {
        const payload = JSON.parse(atob(token.split('.')[1] || token));
        if (payload.userId) {
          // Mock user data restoration - in production, fetch from backend
          dispatch(loginSuccess({
            user: { id: payload.userId, username: 'User', email: '' },
            token: token
          }));
        }
      } catch (error) {
        // Invalid token, remove it
        localStorage.removeItem('authToken');
      }
    }
  }, [dispatch, auth.isAuthenticated]);

  const login = useCallback(async (email: string, password: string) => {
    try {
      setLoading(true);
      console.log('Login attempt:', { email });
      const response = await apiService.login(email, password);
      console.log('Login response:', response);
      if (response.success && response.data) {
        dispatch(loginSuccess(response.data));
        localStorage.setItem('authToken', response.data.token);
        console.log('Login successful, token stored');
        return { success: true };
      } else {
        console.error('Login failed:', response.error);
        return { success: false, error: response.error || 'Login failed' };
      }
    } catch (error) {
      console.error('Login error:', error);
      return { success: false, error: error instanceof Error ? error.message : 'Login failed' };
    } finally {
      setLoading(false);
    }
  }, [dispatch]);

  const logout = useCallback(async () => {
    try {
      await apiService.logout();
    } catch (error) {
      console.error('Logout error:', error);
    } finally {
      localStorage.removeItem('authToken');
      dispatch({ type: 'auth/logout' });
    }
  }, [dispatch]);

  return {
    ...auth,
    loading,
    login,
    logout,
  };
};

// Messages Hook
export const useMessages = (conversationId?: string) => {
  const dispatch = useDispatch();
  const messages = useSelector((state: RootState) => 
    conversationId ? state.chat.messages[conversationId] || [] : []
  );
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const loadMessages = useCallback(async (page: number = 1) => {
    if (!conversationId) return;

    try {
      setLoading(true);
      setError(null);
      const response = await apiService.getMessages(conversationId, page);
      if (response.success && response.data) {
        response.data.forEach(message => {
          dispatch(addMessage(message));
        });
      }
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to load messages');
    } finally {
      setLoading(false);
    }
  }, [conversationId, dispatch]);

  const sendMessage = useCallback(async (content: string) => {
    if (!conversationId) return;

    try {
      setError(null);
      const response = await apiService.sendMessage(conversationId, content);
      if (response.success && response.data) {
        dispatch(addMessage(response.data));
        return { success: true, message: response.data };
      } else {
        return { success: false, error: response.error || 'Failed to send message' };
      }
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Failed to send message';
      setError(errorMessage);
      return { success: false, error: errorMessage };
    }
  }, [conversationId, dispatch]);

  return {
    messages,
    loading,
    error,
    loadMessages,
    sendMessage,
  };
};

// Read Status Hook
export const useReadStatus = (messageId?: string) => {
  const readStatuses = useSelector((state: RootState) => 
    messageId ? state.chat.readStatuses[messageId] || [] : []
  );
  const [loading, setLoading] = useState(false);

  const markAsRead = useCallback(async (deviceId?: string) => {
    if (!messageId) return;

    try {
      setLoading(true);
      const response = await apiService.markMessageAsRead(messageId, deviceId);
      if (response.success) {
        // Real-time update via WebSocket
        websocketService.markAsRead(messageId, deviceId);
      }
    } catch (error) {
      console.error('Failed to mark as read:', error);
    } finally {
      setLoading(false);
    }
  }, [messageId]);

  const getReadStatus = useCallback(async () => {
    if (!messageId) return;

    try {
      setLoading(true);
      const response = await apiService.getReadStatus(messageId);
      if (response.success && response.data) {
        response.data.forEach(status => {
          dispatch(updateReadStatus(status));
        });
      }
    } catch (error) {
      console.error('Failed to get read status:', error);
    } finally {
      setLoading(false);
    }
  }, [messageId]);

  return {
    readStatuses,
    loading,
    markAsRead,
    getReadStatus,
  };
};

// Settings Hook
export const useSettings = () => {
  const settings = useSelector((state: RootState) => state.settings);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const updateSettings = useCallback(async (newSettings: Partial<typeof settings>) => {
    try {
      setLoading(true);
      setError(null);
      const response = await apiService.updateUserSettings(newSettings);
      if (response.success && response.data) {
        dispatch({ type: 'settings/updateSettings', payload: response.data });
        return { success: true };
      } else {
        return { success: false, error: response.error || 'Failed to update settings' };
      }
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to update settings';
      setError(errorMessage);
      return { success: false, error: errorMessage };
    } finally {
      setLoading(false);
    }
  }, []);

  return {
    settings,
    loading,
    error,
    updateSettings,
  };
};

// Encryption Hook
export const useEncryption = () => {
  const [keyPair, setKeyPair] = useState<CryptoKeyPair | null>(null);
  const [loading, setLoading] = useState(false);

  const generateKeys = useCallback(async () => {
    try {
      setLoading(true);
      const newKeyPair = await encryptionService.generateKeyPair();
      setKeyPair(newKeyPair);
      return { success: true, keyPair: newKeyPair };
    } catch (error) {
      return { success: false, error: error instanceof Error ? error.message : 'Key generation failed' };
    } finally {
      setLoading(false);
    }
  }, []);

  const encryptMessage = useCallback(async (message: string, recipientPublicKey: CryptoKey) => {
    try {
      const encrypted = await encryptionService.encryptMessage(message, recipientPublicKey);
      return { success: true, encrypted };
    } catch (error) {
      return { success: false, error: error instanceof Error ? error.message : 'Encryption failed' };
    }
  }, []);

  const decryptMessage = useCallback(async (encryptedData: ArrayBuffer) => {
    try {
      const decrypted = await encryptionService.decryptMessage(encryptedData);
      return { success: true, decrypted };
    } catch (error) {
      return { success: false, error: error instanceof Error ? error.message : 'Decryption failed' };
    }
  }, []);

  useEffect(() => {
    const loadExistingKey = async () => {
      const existingKey = await encryptionService.loadPrivateKey();
      if (existingKey) {
        // Note: We only have the private key, would need to reconstruct the full key pair
        // This is a simplified implementation
        console.log('Existing private key found');
      }
    };

    loadExistingKey();
  }, []);

  return {
    keyPair,
    loading,
    generateKeys,
    encryptMessage,
    decryptMessage,
  };
};

// Local Storage Hook
export const useLocalStorage = <T>(key: string, initialValue: T) => {
  const [storedValue, setStoredValue] = useState<T>(() => {
    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      console.error(`Error reading localStorage key "${key}":`, error);
      return initialValue;
    }
  });

  const setValue = useCallback((value: T | ((val: T) => T)) => {
    try {
      const valueToStore = value instanceof Function ? value(storedValue) : value;
      setStoredValue(valueToStore);
      window.localStorage.setItem(key, JSON.stringify(valueToStore));
    } catch (error) {
      console.error(`Error setting localStorage key "${key}":`, error);
    }
  }, [key, storedValue]);

  const removeValue = useCallback(() => {
    try {
      window.localStorage.removeItem(key);
      setStoredValue(initialValue);
    } catch (error) {
      console.error(`Error removing localStorage key "${key}":`, error);
    }
  }, [key, initialValue]);

  return [storedValue, setValue, removeValue] as const;
};